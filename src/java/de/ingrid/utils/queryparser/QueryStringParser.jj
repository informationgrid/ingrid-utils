/**
 * Ingrid Query String Parser
 */

options {
LOOKAHEAD=2;
STATIC=false;
}

PARSER_BEGIN(QueryStringParser)
package de.ingrid.utils.queryparser;

import java.io.StringReader;


import de.ingrid.utils.query.ClauseQuery;
import de.ingrid.utils.query.FieldQuery;
import de.ingrid.utils.query.IngridQuery;
import de.ingrid.utils.query.TermQuery;

public class QueryStringParser {
     /**
     * Parses the string to a query object representation
     * @param queryString
     * @return ingrid query that contains subqueries
     * @throws ParseException
     */
    public static IngridQuery parse(String queryString) throws ParseException {
    	QueryStringParser parser = new QueryStringParser(new StringReader(queryString));
    	return parser.parse();
    }
}

PARSER_END(QueryStringParser)

<*> TOKEN : {
  <#_NUM_CHAR:   ["0"-"9"] >

| <#_ESCAPED_CHAR: "\\" [ "\\", "+", "-", "!", "(", ")", ":", "^",
                          "[", "]", "\"", "{", "}", "~", "*", "?" ] >
| <#_TERM_START_CHAR: ( ~[ " ", "\t", "\n", "\r", "+", "-", "!", "(", ")", ":", "^",
                           "[", "]", "\"", "{", "}", "~", "*", "?" ]
                       | <_ESCAPED_CHAR> ) >
| <#_TERM_CHAR: ( <_TERM_START_CHAR> | <_ESCAPED_CHAR> | "-" | "+" ) >
| <#_WHITESPACE: ( " " | "\t" | "\n" | "\r") >
}

<DEFAULT, RangeIn, RangeEx> SKIP : {
  <<_WHITESPACE>>
}


<DEFAULT> TOKEN : {
  <AND:       ("AND" | "&&") >
| <OR:        ("OR" | "||") >
| <NOT:       ("NOT" | "!") >
| <PLUS:      "+" >
| <MINUS:     "-" >
| <LPAREN:    "(" >
| <RPAREN:    ")" >
| <COLON:     ":" >
| <CARAT:     "^" > : Boost
| <QUOTED:     "\"" (~["\""])+ "\"">
| <TERM:      <_TERM_START_CHAR> (<_TERM_CHAR>)*  >
| <DATATYPE:      <_TERM_START_CHAR> "datatype" <COLON> (<_TERM_CHAR>)* >
| <FIELD:      <_TERM_START_CHAR> (<_TERM_CHAR>)* <COLON> (<_TERM_CHAR>)* >
| <FUZZY_SLOP:     "~" ( (<_NUM_CHAR>)+ ( "." (<_NUM_CHAR>)+ )? )? >
| <PREFIXTERM:  <_TERM_START_CHAR> (<_TERM_CHAR>)* "*" >
| <WILDTERM:  <_TERM_START_CHAR>
              (<_TERM_CHAR> | ( [ "*", "?" ] ))* >
| <RANGEIN_START: "[" > : RangeIn
| <RANGEEX_START: "{" > : RangeEx
}

<Boost> TOKEN : {
<NUMBER:    (<_NUM_CHAR>)+ ( "." (<_NUM_CHAR>)+ )? > : DEFAULT
}

<RangeIn> TOKEN : {
<RANGEIN_TO: "TO">
| <RANGEIN_END: "]"> : DEFAULT
| <RANGEIN_QUOTED: "\"" (~["\""])+ "\"">
| <RANGEIN_GOOP: (~[ " ", "]" ])+ >
}

<RangeEx> TOKEN : {
<RANGEEX_TO: "TO">
| <RANGEEX_END: "}"> : DEFAULT
| <RANGEEX_QUOTED: "\"" (~["\""])+ "\"">
| <RANGEEX_GOOP: (~[ " ", "}" ])+ >
}

IngridQuery parse() :
	{ 
		// variables
		Token token;
		IngridQuery query = new IngridQuery();
		IngridQuery subQuery;
		String dataType;
	}
	{
(
subQuery = term()
	{
		query.addTerm((TermQuery)subQuery);

	}
| subQuery = field()
	{
		if(((FieldQuery)subQuery).getFieldName().equals("datatype")){
           query.setDataType(((FieldQuery)subQuery).getFieldValue());
        } else {
           query.addField((FieldQuery)subQuery); 
        }
	}
| subQuery = clause()
	{ 
		query.addClause((ClauseQuery)subQuery);
	}	

)*
	{return  query;}
}


	
// field
	IngridQuery field() :
	{
		FieldQuery query;
		Token t;
		int required = IngridQuery.AND;	
	}
	{
	(<OR>{required =IngridQuery.OR; } | <NOT> {required =IngridQuery.NOT; }| <AND> {required =IngridQuery.AND; })?
	t=<FIELD>
	{query = new FieldQuery( required, t.image);}
	{return query;}
	}
	
	
// term	
	IngridQuery term() :
	{
		TermQuery query;
		Token t;
		int required = IngridQuery.AND;
	}
	{
	(<OR>{required =IngridQuery.OR; } | <NOT> {required =IngridQuery.NOT; }| <AND> {required =IngridQuery.AND; })?
	t=<TERM>
	{query = new TermQuery(required, t.image);}
	{return query;}
	}

// clause...
	IngridQuery clause() :
	{
		ClauseQuery query;
		Token t;
		int required = IngridQuery.AND;
		IngridQuery subQuery;
	}
	{
	(<OR>{required =IngridQuery.OR; } | <NOT> {required =IngridQuery.NOT; }| <AND> {required =IngridQuery.AND; })?
	{query =  new ClauseQuery( required );}
	<LPAREN>
	 (
	subQuery = term()
		{
			query.addTerm((TermQuery)subQuery);
		}
	| subQuery = field()
		{
			query.addField((FieldQuery)subQuery);
		}
	| subQuery = clause()
		{ 
			query.addClause((ClauseQuery)subQuery);
		}	
	
	)*
	 <RPAREN>
	
	{return  query;}
	}	
	
